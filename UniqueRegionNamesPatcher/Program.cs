using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Threading.Tasks;
using UniqueRegionNamesPatcher.Extensions;
using UniqueRegionNamesPatcher.Utility;

namespace UniqueRegionNamesPatcher
{
    public class Program
    {
        private static Lazy<Settings> _lazySettings = null!;
        private static Settings Settings => _lazySettings.Value;

        private static readonly List<WorldspaceProcessor> Handlers = new();

        public static async Task<int> Main(string[] args)
            => await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "UniqueRegionNamesPatcher.esp")
                .SetAutogeneratedSettings("Settings", "settings.json", out _lazySettings, false)
                .Run(args);

        private static void InitializeHandlers(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Handlers.Clear();

            /* v This section should be put in a loop in the future v */

            // Add a handler for Tamriel:
            var handler = new WorldspaceProcessor(Settings.TamrielSettings.GetUrnRegionMap(ref state));
            Handlers.Add(handler);
            Console.WriteLine($"Added {nameof(WorldspaceProcessor)} for {nameof(Worldspace)} '{handler.RegionMap.WorldspaceFormKey}' ({handler.RegionMap.WorldspaceFormKey.ToLink<IWorldspaceGetter>()?.Resolve(state.LinkCache).EditorID})");

            if (Settings.verbose)
            {
                var regions = handler.RegionMap.Regions;

                Console.WriteLine($"Parsed {regions.Count} region{(regions.Count.Equals(1) ? "" : "s")} containing {handler.RegionMap.Map.Count} cell{(handler.RegionMap.Map.Count.Equals(1) ? "" : "s")}:");

                int longestEdID = 0, longestName = 0;
                regions.ForEach(delegate (RegionWrapper rw)
                {
                    if (rw.EditorID.Length > longestEdID)
                        longestEdID = rw.EditorID.Length;
                    if (rw.Name != null && rw.Name.Length > longestName)
                        longestName = rw.Name.Length;
                });

                Console.WriteLine('{');
                foreach (var region in regions)
                    Console.WriteLine($"    {{ EditorID: '{region.EditorID}':{new string(' ', longestEdID + 4 - region.EditorID.Length)}Displayname: '{region.Name}'{new string(' ', longestName - region.Name?.Length ?? 0)} }},");
                Console.WriteLine('}');
            }

            /* ^ This section should be put in a loop in the future ^ */
        }

        private static WorldspaceProcessor? GetHandlerForWorldspace(IWorldspaceGetter wrld) => Handlers.FirstOrDefault(h => h.AppliesTo(wrld));

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Console.WriteLine("===================");

            InitializeHandlers(state);

            int totalChanges = 0;
            foreach (var wrldGetter in state.LoadOrder.ListedOrder.Worldspace().WinningContextOverrides())
            {
                if (GetHandlerForWorldspace(wrldGetter) is WorldspaceProcessor handler)
                {
                    Worldspace copy = wrldGetter.DeepCopy();
                    int changes = 0;
                    handler.Process(ref copy, ref changes);
                    Console.WriteLine($"Changed region data for {changes} cells in worldspace {copy.EditorID}");
                    state.PatchMod.Worldspaces.Set(copy);
                    totalChanges += changes;
                }
            }

            Console.WriteLine($"Process Complete.\nUpdated region data for {totalChanges} cell{(totalChanges == 1 ? "" : "s")}.");
        }
    }
}
